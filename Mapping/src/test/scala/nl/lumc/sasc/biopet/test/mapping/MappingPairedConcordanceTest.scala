package nl.lumc.sasc.biopet.test.mapping

import java.io.File

import nl.lumc.sasc.biopet.test.mapping.reference.ReferencePairedTemplate
import nl.lumc.sasc.biopet.test.{ Biopet, SummaryPipeline }
import org.json4s._
import org.testng.annotations.Test

import scala.io.Source

/**
 * Check values generated by `MappingPaired`, values should be identical or falling into a certain range.
 *
 */
trait MappingPairedConcordanceTest extends MappingPaired with SummaryPipeline {
  /** JSON paths for summary. */
  protected val bamMetricsPath = (sampleId, libId) match {
    case (Some(sid), Some(lid)) => Seq("samples", sid, "libraries", lid, "bammetrics")
    case otherwise              => Seq()
  }
  protected val statsPath = bamMetricsPath :+ "stats"

  override def functionalTest = true

  addSummaryTest(statsPath :+ "biopet_flagstat",
    Seq(
      _ \ "All" should haveValue(20000),
      x => (x \ "Mapped").extract[Double] shouldEqual 19800 +- 200,
      x => (x \ "ProperPair").extract[Double] shouldEqual 20000 +- 100,
      _ \ "ReadPaired" should haveValue(20000),
      _ \ "FirstOfPair" should haveValue(10000),
      _ \ "SecondOfPair" should haveValue(10000),
      x => (x \ "Duplicates").extract[Int] should be < 10,
      x => (x \ "MAPQ>30").extract[Int] shouldEqual 19750 +- 250,
      x => (x \ "MAPQ>40").extract[Int] shouldEqual 19750 +- 250,
      x => (x \ "MAPQ>50").extract[Int] shouldEqual 19750 +- 250
    ))

  addSummaryTest(statsPath :+ "CollectInsertSizeMetrics" :+ "metrics",
    Seq(
      x => (x \ "READ_PAIRS").extract[Int] shouldEqual 10000 +- 50,
      x => (x \ "MEDIAN_INSERT_SIZE").extract[Int] shouldEqual 500 +- 15,
      x => (x \ "MEAN_INSERT_SIZE").extract[Double] shouldEqual 500.0 +- 15.0,
      _ \ "PAIR_ORIENTATION" should haveValue("FR")
    ))

}

trait MappingPairedDNA extends MappingPairedConcordanceTest {

  addSummaryTest(statsPath :+ "wgs" :+ "metrics",
    Seq(
      x => (x \ "MEDIAN_COVERAGE").extract[Int] shouldEqual 63 +- 2,
      x => (x \ "MEAN_COVERAGE").extract[Double] shouldEqual 63.0 +- 2.0,
      x => (x \ "SD_COVERAGE").extract[Double] shouldEqual 11.0 +- 2.0
    ))

}

class MappingPairedDNATest extends MappingPairedDNA

//class MappingPairedRNA extends MappingPairedConcordanceTest

trait MappingPairedWiggleConcordance extends MappingPaired {
  override def functionalTest = true

  override def generateWig = Some(true)

  @Test()
  def similarWiggleTrack: Unit = {
    // Loading the reference wiggle (A)
    val referenceWiggle = new File(Biopet.fixtureDir + File.separator + "mapping", "wgs1-testlib.final.bam.wig")

    val tableA = loadWiggleFile(referenceWiggle)
    val tableB = loadWiggleFile(finalWigFile)

    tableB.size shouldBe tableA.size

    // function: do a correlation computation for file A and B
    val valuesA = tableA.foldRight(List[Double]())((A, B) => B :+ A.head._2)
    val valuesB = tableB.foldRight(List[Double]())((A, B) => B :+ A.head._2)

    val correlationScore: Double = pearsonScore(valuesA, valuesB).getOrElse(0.0)

    // in the comparison we allow 1 percent difference.
    correlationScore should be > 0.99

  }

  def finalWigFile: File = new File(outputDir, s"${sampleId.get}-${libId.get}.final.bam.wig")

  /**
   *
   * Taken from http://alvinalexander.com/scala/scala-pearson-correlation-score-algorithm-programming-collective-intelligence
   * @param a List containing Doubles
   * @param b List containing Doubles
   * @return
   */
  def pearsonScore(a: List[Double], b: List[Double]): Option[Double] = {

    assert(a.size == b.size, "Sizes of both Maps are not equal")
    val n = a.size
    // add up all the preferences
    val sum1 = a.sum
    val sum2 = b.sum

    // sum up the squares
    val sum1Sq = a.foldLeft(0.0)(_ + Math.pow(_, 2))
    val sum2Sq = b.foldLeft(0.0)(_ + Math.pow(_, 2))

    // sum up the products
    val pSum = (a.view.zipWithIndex foldLeft 0.0) {
      case (acc, (value, index)) => acc + (value * b(index))
    }

    //  // calculate the pearson score
    val numerator = pSum - (sum1 * sum2 / n)
    val denominator = Math.sqrt((sum1Sq - Math.pow(sum1, 2) / n) * (sum2Sq - Math.pow(sum2, 2) / n))
    if (denominator == 0) None else Some(numerator / denominator)
  }

  /**
   * Wigglefile loader
   *
   * @param wiggleFile Path to wiggleFile (as File-object)
   */
  def loadWiggleFile(wiggleFile: File): List[Map[String, Double]] = {
    val reader = Source.fromFile(wiggleFile)
    val lines = reader.getLines()
      .map(line => parseWiggleLine(line))
      .filterNot(_ == Map.empty)
    lines.toList
  }

  /**
   * Converts wiggle line to a Map(binstart -> value)
   *
   * @param wiggleLine Raw line taken from the wiggle
   */
  def parseWiggleLine(wiggleLine: String): Map[String, Double] = {
    var result: Map[String, Double] = Map.empty

    // line could start with "track"
    // line could start with variableStep

    if (wiggleLine.startsWith("track") || wiggleLine.startsWith("variableStep")) {
      result = Map.empty
    } else {
      val values: Array[String] = wiggleLine.stripLineEnd.split("\t")
      result = Map(values(0) -> values(1).toDouble)
    }
    result
  }
}

class MappingWiggleBWA extends ReferencePairedTemplate("bwa-mem") with MappingPairedWiggleConcordance